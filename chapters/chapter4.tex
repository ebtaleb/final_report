\chapter{Interfacing with LLDB\label{cha:chapter4}}

\section{Introduction to LLDB}

LLDB\autocite{lldb} aims to be a modern source-level debugger,
with a modular plug-in architecture (for object file
formats, programming language support, symbol files, specific hosts and
targets), while providing a C++ \gls{api} with Python bindings for controlling debugger
instances.

LLDB is part of the LLVM project, a collection of modular compiler tools and
components, including the Clang compiler frontend, the LLVM middle end intermediary
representation and a target-independent backend.

\subsection{An OCaml language plugin for LLDB}

At this point, a OCaml program compiled with the modified compiler
presented previously contains more debugging information than before:
there are more places where a breakpoint can be set in the program, and
the binary contains runtime location of variables and type information as well.

However, all this information cannot be used directly as it is yet,
as several limitations comes with the use of LLDB from a distribution package:

\begin{itemize}
    \item Current versions of LLDB have no knowledge of the OCaml \gls{runtime},
    \item LLDB bindings doesnt allow access to the DWARF data or symbol
        demangling.
\end{itemize}

It has now been possible for less than a year for LLDB to support debugging of programs
written in other programming languages \autocite{lldbpl} using plugin facilities for
data formatting and pretty-printing, expression evaluation and other static and
dynamic properties of the language to support.

Hence, a barebones OCaml LLDB plugin has been conceived with the following
features:

\begin{itemize}
    \item A custom DWARF parser: If the DWARF data nesting and structure
        changes, it is possible to adapt the parser it accordingly with minor
        changes.
    \item A minimal type system where all values are considered as 64-bit
        unsigned integers:
        since data structures used to represent OCaml types may
        change from one version to another, it might not be maintainable to update
        the LLDB plugin at each release.
        Out of backwards compatibility concerns, value
        interpretation according to their types will be left to a debugging
        layer aware of OCaml types.
    \item Support for symbol demangling.
    At the binary level, OCaml identifiers are mapped to
    symbols of the form camlFoo\_\_var\_1234, where Foo is the module name, var
    a function or variable identifier and 1234 a unique value generated by the
    lambda pass to handle variable shadowing.
    The plugin makes demangled symbols available for easier function breakpoint setting.
\end{itemize}

\section{The ocp-lldb debugger}

%\begin{figure}
\centering
\begin{tikzpicture}[remember picture]
    \node[xshift=0cm,yshift=-15cm] at (current page.north) {
            \input{./tikz_pic/ocpll.tikz}
        };
\end{tikzpicture}
%\end{figure}

%\begin{figure}
  %\centering
%\end{figure}

\subsection{ocplib-lldb}

It is a library that generate \glspl{binding} to the C++ LLDB \gls{api} by parsing the LLDB header files. It then outputs stubs/mock functions in OCaml and C++.
Most classes and methods of the API are supported, with the exception of static
methods.
Access to C++ objects is done through the OCaml-C \gls{ffi}.

\subsection{ocp-lldb}

It is a debugging layer written in OCaml,
which displays OCaml values using runtime type information added for memory profiling.

It leverages the OCaml compiler frontend as a library
allowing use of the lexer and parser and typing facilities,
especially useful when operating over the non-typed and typed OCaml ASTs.

The typed AST is deserialized from the binary, then is iterated over to extract a simpler tree
structure used as a symbol table, allowing type lookup the type of an
identifier.

Typed information is also included in OCaml boxed values thanks to the memory
profiling facilities.

Using the values available from the DWARF data and LLDB, ocp-lldb can then display
OCaml values according to their type.

\section{Runtime memory representation of OCaml values}

All values represented as a single word (of either 32 or 64 bits depending on
the architecture).

To differentiate between pointers and integer values at runtime, the runtime
system uses a tagged pointer representation, the least significant bit of a
value is used as a tag : an OCaml integer is encoded as a 31 or 63-bit integer
using the formula $ (x \ShiftLeft 1) \BitOr 1 $.\\

\vspace{1mm}
Mere integers are not boxed, the tag bit will be set to one
as for pointers, since they are word-aligned, their tag bit will be set to zero
(they are multiples of 4, therefore they will always end with two 0 bits).\\

\vspace{1mm}
\Glspl{boxed} are represented as a single word pointer to a block structure, made of a
header followed by data.
The header contains metadata about the value such as size of the block, and tag describing what type of data it
contains.
%add level of indirection / deref

\begin{itemize}
    \item the \textbf{int} and \textbf{char} types are unboxed,
    \item \textbf{unit}, \textbf{false} and the empty list are represented as the integer 0,
    \item \textbf{true} is represented as the integer 1,
    \item arrays, records and tuples are represented as a block with an array of OCaml values,
    \item records with floats fields and arrays of floats as a block with an
        array of unboxed floats,
    \item for variant types, variants without type parameters are unboxed ascending
integers, whereas non-constant variants with parameters are boxed.
\end{itemize}

