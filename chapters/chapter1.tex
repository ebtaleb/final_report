\chapter{Introduction\label{cha:chapter1}}

There are things to be aware of when dealing with \gls{native} code:
\begin{itemize}
    \item the instructions themselves do not retain any information about the abstractions of the source programming language in the
original source code, because the CPU does not need them to run the program,

%backend compiler passes
%reorganize and reposition instructions
\item furthermore, compiler \glspl{optim} can move, add and transform \glspl{ir} in such a way that it might not be possible to identify which source code statement correpsond to a particular set of instructions.
\end{itemize}

Hence, compilation of a program to native code involve a huge loss of information, information that is usually collected by compilers and bundled with binaries and \glspl{objectfile} in the form of debugging information for debuggers.

\section{Motivation\label{sec:moti}}

There are three main reasons for this work :

\begin{itemize}
    \item Cases where it is necessary to debug native code may arise, e.g a bug appearing only in an optimized version of a program
    \item
\end{itemize}

%(if inline assembly code is inserted manually by a developer e.g)
It is usually easier to debug an unoptimized program,

\indent There is for now no unified solution for debugging OCaml native code on any platform.
Some work was made, the bare minimum is here (\gls{backtrace} support, partial step by step into function entry points and function calls)
\\
\\
\indent mainstream debuggers remain largely unaware of the OCaml native runtime % management of values
no variable inspection,
moslty assembly/ raw memory view, arcane knowledge of target architecture, not available to every developper
but inspecting assembly code instruction and memory becomes a tedious task in a large program

\section{Objectives\label{sec:objective}}
The work presented here aims to address
Improve debugging support for OCaml native compiled code
Enhance the debugging experience

diminish cognitive strain on devs

targeting developers lacking knowledge of the target architecture

\begin{algorithmic}[1]
	\If{some condition is true}
	\State do some processing
	\ElsIf{some other condition is true}
	\State do some different processing
	\ElsIf{some even more bizarre condition is met}
	\State do something else
	\Else
	\State do the default actions
	\EndIf
\end{algorithmic}

\section{Scope\label{sec:scope}}

Find a way to generate more debugging information (which info)
Store it in a adequate/fitting debug data format

Improve a prototype of native debugger based on LLDB

The OCamlPro company
Internship timeline (every forthnight)

\section{Outline\label{sec:outline}}

\textbf{Chapter \ref{cha:chapter2}} is usually termed 'Related Work', 'State of the Art' or 'Fundamentals'. Here you will describe relevant technologies and standards related to your topic. What did other scientists propose regarding your topic? This chapter makes about 20-30 percent of the complete thesis.
\\
The DWARF standard
The DWARF format
Example
The ocplib-dwarf library
\\
\textbf{Chapter \ref{cha:chapter3}} analyzes the requirements for your component. This chapter will have 5-10 pages.
\\
The OCaml native toolchain
hl architecture, compilation process

debug loc
dwarf
types
for each, what effect is achieved, tradeoffs
\\
\textbf{Chapter \ref{cha:chapter4}} is usually termed 'Concept', 'Design' or 'Model'. Here you describe your approach, give a high-level description to the architectural structure and to the single components that your solution consists of. Use structured images and UML diagrams for explanation. This chapter will have a volume of 20-30 percent of your thesis.
\\
The OCaml native runtime system
LLDB (API)
ocp(lib)-lldb (hl archi)

additions to LLDB and ocp-lldb
\\
\textbf{Chapter \ref{cha:chapter6}} is usually termed 'Evaluation' or 'Validation'. How did you test it? In which environment? How does it scale? Measurements, tests, screenshots. This chapter will have a volume of 10-15 percent of your thesis.
\\
How does it fare?
\\
\textbf{Chapter \ref{cha:chapter7}} summarizes the thesis, describes the problems that occurred and gives an outlook about future work. Should have about 4-6 pages.

Am√©liorations
Work left to do

Enhancements

User experience/interface minor:
- no function name symbol displayed in the backtrace
- no proper stop at breakpoint set on a module's entry point (in disassembled code) rather than in source
- global variables becomes available/displayed after second call to `frame variable`


Extensions
Work being done in same direction

TODO:
We developed the first prototype of a native debugger for OCaml, based on the LLDB debugging framework on top of LLVM. For that, we first generated a full OCaml binding for the LLDB library, by parsing the C++ headers of the libraries and automatically generating OCaml and C++ stubs. We were then able to use the OCaml binding to develop several tools, ranging from a simple tool that displays the internal GC information of a finished OCaml application, to an almost complete debugger, which displays OCaml values using runtime type information added for memory profiling.
