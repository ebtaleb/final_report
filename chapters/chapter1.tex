\chapter{Introduction\label{cha:chapter1}}

There are things to be aware of when dealing with \gls{native} code:
\begin{itemize}
    \item the instructions themselves do not retain any information about the abstractions of the source programming language in the
original source code, because the CPU does not need them to run the program

%backend compiler passes
%reorganize and reposition instructions
\item furthermore, compiler \glspl{optim} can move, add and transform \glspl{ir} in such a way that it might not be possible to identify which source code statement correpsond to a particular set of instructions
\end{itemize}

hence, compilation of a program to native code involve a huge loss of information, information that is usually collected by compilers and bundled with binaries and \glspl{objectfile} in the form of debugging information for debuggers.

\section{Motivation\label{sec:moti}}

necessary to debug native code, in cases where a bug might appear only in a optimized binary/program
%(if inline assembly code is inserted manually by a developer e.g)
easier to debug unoptimized, but inspecting assembly code instruction and memory becomes a tedious task in a large program

there is for now no lasting? comprehensive? definitive? solution for debugging OCaml native code
partial effort was made, bare minimum is here (backtrace support, partial step by step into function entry points and function calls)

no variable inspection, main debuggers unaware of the OCaml native runtime management of values
moslty assembly/ raw memory view, arcane knowledge of target architecture, not available to every developper

\section{Objectives\label{sec:objective}}
The work presented here aims to address
Improve debugging support for OCaml native compiled code
Enhance the debugging experience

diminish cognitive strain on devs

targeting developers lacking knowledge of the target architecture

\section{Scope\label{sec:scope}}

Find a way to generate more debugging information (which info)
Store it in a adequate/fitting debug data format

Improve a prototype of native debugger based on LLDB

The OCamlPro company
Internship timeline (every forthnight)

\section{Outline\label{sec:outline}}

\textbf{Chapter \ref{cha:chapter2}} is usually termed 'Related Work', 'State of the Art' or 'Fundamentals'. Here you will describe relevant technologies and standards related to your topic. What did other scientists propose regarding your topic? This chapter makes about 20-30 percent of the complete thesis.
\\
The DWARF standard
The DWARF format
Example
The ocplib-dwarf library
\\
\textbf{Chapter \ref{cha:chapter3}} analyzes the requirements for your component. This chapter will have 5-10 pages.
\\
The OCaml native toolchain
hl architecture, compilation process

debug loc
dwarf
types
for each, what effect is achieved, tradeoffs
\\
\textbf{Chapter \ref{cha:chapter4}} is usually termed 'Concept', 'Design' or 'Model'. Here you describe your approach, give a high-level description to the architectural structure and to the single components that your solution consists of. Use structured images and UML diagrams for explanation. This chapter will have a volume of 20-30 percent of your thesis.
\\
The OCaml native runtime system
LLDB (API)
ocp(lib)-lldb (hl archi)

additions to LLDB and ocp-lldb
\\
\textbf{Chapter \ref{cha:chapter6}} is usually termed 'Evaluation' or 'Validation'. How did you test it? In which environment? How does it scale? Measurements, tests, screenshots. This chapter will have a volume of 10-15 percent of your thesis.
\\
How does it fare?
\\
\textbf{Chapter \ref{cha:chapter7}} summarizes the thesis, describes the problems that occurred and gives an outlook about future work. Should have about 4-6 pages.

Am√©liorations
Work left to do

Enhancements

User experience/interface minor:
- no function name symbol displayed in the backtrace
- no proper stop at breakpoint set on a module's entry point (in disassembled code) rather than in source
- global variables becomes available/displayed after second call to `frame variable`


Extensions
Work being done in same direction
