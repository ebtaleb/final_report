\chapter{Introduction\label{cha:chapter1}}

There are things to be aware of when dealing with machine native code
the instructions themselves do not retain any information about /concerning the abstractions in the
original source code, because the CPU does not need it

backend compiler passes
%reorganize and reposition instructions
furthermore, compiler optimizations can move, add and transform instructions in such a way that it might not be possible
to identify which source code statement correpsond to a particular/specific set of machine instruction

hence, compilation of a program to native code involve a huge loss of information
information that is usually collected by compilers and bundled with binaries/object files in the form of
debugging information for debuggers.

\section{Motivation\label{sec:moti}}

necessary to debug native code, in cases where a bug might appear only in a optimized binary/program
%(if inline assembly code is inserted manually by a developer e.g)
easier to debug unoptimized, but inspecting assembly code instruction and memory becomes a tedious task in a large program

there is for now no lasting? comprehensive? definitive? solution for debugging OCaml native code
partial effort was made, bare minimum is here (backtrace support, partial step by step into function entry points and function calls)

no variable inspection, main debuggers unaware of the OCaml native runtime management of values
moslty assembly/ raw memory view, arcane knowledge of target architecture, not available to every developper

\section{Objectives\label{sec:objective}}
The work presented here aims to address
Improve debugging support for OCaml native compiled code
Enhance the debugging experience

diminish cognitive strain on devs

targeting developers lacking knowledge of the target architecture

\section{Scope\label{sec:scope}}

Find a way to generate more debugging information (which info)
Store it in a adequate/fitting debug data format

Improve a prototype of native debugger based on LLDB

The OCamlPro company
Internship timeline (every forthnight)

\section{Outline\label{sec:outline}}

\textbf{Chapter \ref{cha:chapter2}} is usually termed 'Related Work', 'State of the Art' or 'Fundamentals'. Here you will describe relevant technologies and standards related to your topic. What did other scientists propose regarding your topic? This chapter makes about 20-30 percent of the complete thesis.
\\
The DWARF standard
The DWARF format
Example
The ocplib-dwarf library
\\
\textbf{Chapter \ref{cha:chapter3}} analyzes the requirements for your component. This chapter will have 5-10 pages.
\\
The OCaml native toolchain
hl architecture, compilation process

debug loc
dwarf
types
for each, what effect is achieved, tradeoffs
\\
\textbf{Chapter \ref{cha:chapter4}} is usually termed 'Concept', 'Design' or 'Model'. Here you describe your approach, give a high-level description to the architectural structure and to the single components that your solution consists of. Use structured images and UML diagrams for explanation. This chapter will have a volume of 20-30 percent of your thesis.
\\
The OCaml native runtime
LLDB (API)
ocp(lib)-lldb (hl archi)

additions to LLDB and ocp-lldb
\\
\textbf{Chapter \ref{cha:chapter5}} describes the implementation part of your work. Don't explain every code detail but emphasize important aspects of your implementation. This chapter will have a volume of 15-20 percent of your thesis.
\\

\\
\textbf{Chapter \ref{cha:chapter6}} is usually termed 'Evaluation' or 'Validation'. How did you test it? In which environment? How does it scale? Measurements, tests, screenshots. This chapter will have a volume of 10-15 percent of your thesis.
\\
How does it fare?
\\
\textbf{Chapter \ref{cha:chapter7}} summarizes the thesis, describes the problems that occurred and gives an outlook about future work. Should have about 4-6 pages.

&& Am√©liorations
&& Extensions
Work being done in same direction
