\chapter{Introduction to the DWARF format\label{cha:chapter2}}

To establish correspondence between high-level source code and low-level machine
code, one wants to:
\begin{itemize}
    \item collect all information generated in the compiling process
    \item and represent that information in a suitable format usable by
        debuggers, concisely and in a compact manner.
\end{itemize}

DWARF is a debugging data format allowing support for source level debugging.

\begin{itemize}
    \item it is language agnostic, independent of compiler tooling (linker/assembler), target architecture and debuggers.
    \item it is somewhat object file agnostic, although it was designed along the ELF object file format.
    \item it is standardized, meaning it has specifications and norms codified into
        a formal document. A commitee oversees extensions to the standard to
        follow the appearance of programming languages and their evolution
\end{itemize}

\section{Storage}

DWARF data is emitted by the compiler at the code generation step.
At the assembling step, it is stored in particular sections in the object file.

When linking the final binary, the DWARF sections of each object file are
put together in their common corresponding section.

Here is a description of relevant DWARF sections and their contents:

\begin{description}[labelwidth=\widthof{\bfseries .debug\_abbrev},align=parright]
    \item[.debug\_abbrev] Abbreviations used to decode the .debug\_info section
    \item[.debug\_frame] \gls{cfi} table
    \item[.debug\_info] Core DWARF data section
    \item[.debug\_line] Line number information table
    \item[.debug\_loc] Location lists for runtime location of variables and parameters
    \item[.debug\_str] String table reference in .debug\_info
\end{description}

Multiple techniques are used to reduce the size of the debugging information:

\begin{itemize}
    \item LEB128, a variable length compression algorithm for storage of
        signed and unsigned integers of arbitrary size.
        It is used in DWARF to encode values of various fields (like attributes).
    \item Some of the section tables can become quite large in size.
        In order to save space, those tables are encoded as bytecode instructions
        to be executed by state machines to obtain their fully expanded form.
\end{itemize}

\section{Structure}

\subsection{Debugging information entry}

In DWARF, the base entity manipulated is called an debugging information entry, or DIE.
A DIE is made of a tag specifying what language construct it describes and a list of attributes giving more details concerning that construct.

A DIE tag can designate for example entities such as:
\begin{description}
    \item[DW\_TAG\_subprogram] — A subroutine/function
    \item[DW\_TAG\_variable] — A variable
    \item[DW\_TAG\_formal\_parameter] — An argument within function parameters
    \item[DW\_TAG\_lexical\_block] - Define lexical scoping of local variables
    \item[DW\_TAG\_base\_type] - Primitive type not defined in terms of other
        types
\end{description}

An attribute is a name/value couple.
The name attribute indicates what the value represents (name, absolute address,
bytecode, offset, string, integer) and what class of values are supported
It is hence possible for attributes values to reference other DIEs and DWARF sections.

\begin{description}
    \item[DW\_AT\_name] String naming the designated DIE
    \item[DW\_AT\_stmt\_list] Offset referencing a location list
    \item[DW\_AT\_type] Reference to a type DIE
    \item[DW\_AT\_low\_pc] address of the first machine instruction
    \item[DW\_AT\_high\_pc] address or offset of the first location past the last instruction
\end{description}

A DIE can be nested in another parent DIE, have siblings and children,
It can be represented as a tree with an arbitrary number of children.

\subsection{Compilation unit}

It designates two entities :

\begin{itemize}
    \item each separately compiled source file is considered as a compilation
        unit,
    \item the root of a DIE tree that starts the DWARF data for the source file it represents
        It contains general information about the compilation,
        such as the programming language, the compiler version used, source file name, flags
\end{itemize}

\subsection{Example}

An example C program and the DWARF output generated from the objdump utility can be
found there as annexes.

\begin{itemize}
    \item  There is a single compilation unit root DIE has two functions, with information about where they are declared in the source, their names, their visibility as symbols (static to the file or not) and address ranges delimiting which instructions constitutes them.

    \item  The f function entry contains several variable entries for local, i and j.
Its frame base address is contained in the rbp register,
and runtime location of its arguments and local variables is specified with an
offset relative to that frame base address, e.g the argument x is located at the
address contained in the rbp register minus 4.
There is a offset to a base type entry for int, it is signed and takes 4 bytes.

    \item j is shadowed by another variable of same name in a block, but both variables
have different frame pointer offsets.

\end{itemize}


The program's assembly instructions are interspersed with DWARF .loc directives mapping sets of
instructions to their respective statement location in the source.
The \gls{cfi} directives indicate where the \gls{cfa} is on the stack at all times, even when the code is optimized.

%7.10.10 .cfi_def_cfa_register register
%.cfi_def_cfa_register modifies a rule for computing CFA. From now on register will be used instead of the old one. Offset remains the same.

%7.10.11 .cfi_def_cfa_offset offset
%.cfi_def_cfa_offset modifies a rule for computing CFA. Register remains the same, but offset is new. Note that it is the absolute offset that will be added to a defined register to compute CFA address.

%7.10.13 .cfi_offset register, offset
%Previous value of register is saved at offset offset from CFA.

%usually role of saved ebp in the function prologue.
%.cfi_def_cfa_offset 16
 %: rbp - 8 is return address, rbp - 16 is CFA

%access to base pointer from previous frame without using (e/r)bp, can be omitted
%with optimizations, is optional

\section{The ocplib-dwarf library}

%it is a library written in OCaml

It allows its users to work with DWARF data programmatically in OCaml,
reads and prints DWARF data in a human readable format similar to objdump.
This tool was made in a effort to learn about the DWARF format during the internship.

The DWARF emission writing and editing features are not yet implemented.his task is left to compilers

high level desc

%todo prepare a schema

driver with command line option handling

offers abstraction that allow DWARF data manipulation
can visualize the DIE tree structure in debug\_info in DOT format using graphviz
to emulate mutable trees, a zipper library was implemented

utility functions for reading binary data

section parsing implemented accordingly to the DWARF4 standard by its own module
printing module operates on DWARF data structures in ocaml

hexadecimal view available for debugging purposes

It could be possible to use that library in a custom debugger fully in OCaml
% not used in ocp-lldb, since LLDB already handles that information
% except for the ptrace primitives, would use FFI
